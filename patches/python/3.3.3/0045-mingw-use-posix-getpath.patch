diff -urN a/configure.ac b/configure.ac
--- a/configure.ac	2013-12-11 01:53:43.449551900 +0000
+++ b/configure.ac	2013-12-11 01:53:48.591846000 +0000
@@ -596,6 +596,66 @@
 fi
 AC_MSG_RESULT($MACHDEP)
 
+# Windows uses ; to separate paths, everything else uses :
+AC_MSG_CHECKING(DELIM)
+DELIM=:
+if test "$MACHDEP" = "win"
+then
+	DELIM=\;
+fi
+AC_MSG_RESULT([$DELIM])
+AC_SUBST(DELIM)
+
+# On 'semi-native' build systems (MSYS*/Cygwin targeting MinGW-w64)
+# _sysconfigdata.py will contain paths that are correct only in the
+# build environment. This means external modules will fail to build
+# without setting up the same env and also that the build of Python
+# itself will fail as the paths are not correct for the host tools.
+#
+# Also, getpath.c uses GetModuleFileNameW (replacing \ with /) and
+# compares that with the define VPATH (passed in via command-line)
+# to determine whether it's the build- or the installed-Python.
+#
+# To work around these issues a set of _b2h variables are created:
+# VPATH_b2h, abs_srcdir_b2h and abs_builddir_b2h
+# .. where b2h stands for build to host. sysconfig.py replaces path
+# prefixes matching the non-b2h versions with the b2h equivalents.
+#
+# (note this assumes the host compilers are native and *not* cross
+#  - in the 'semi-native' scenario only that is.)
+
+AC_DEFUN([ABS_PATH_HOST],
+[$1=$(cd $$2 && pwd)
+  case $build_os in
+    mingw*)
+      case $host_os in
+        mingw*) $1=$(cd $$2 && pwd -W) ;;
+        *) ;;
+      esac
+      ;;
+    cygwin*)
+      case $host_os in
+        mingw*) $1=$(cygpath -w -m $$2) ;;
+        *) ;;
+      esac
+      ;;
+  esac
+AC_SUBST([$1])
+])
+
+AC_MSG_CHECKING(absolute host location of VPATH)
+ABS_PATH_HOST([VPATH_b2h],[srcdir])
+AC_MSG_RESULT([$VPATH_b2h])
+
+AC_MSG_CHECKING(absolute host location of srcdir)
+ABS_PATH_HOST([abs_srcdir_b2h],[srcdir])
+AC_MSG_RESULT([$abs_srcdir_b2h])
+
+my_builddir=.
+AC_MSG_CHECKING(Absolute host location of builddir)
+ABS_PATH_HOST([abs_builddir_b2h],[my_builddir])
+AC_MSG_RESULT([$abs_builddir_b2h])
+
 AC_MSG_CHECKING([for init system calls])
 AC_SUBST(INITSYS)
 case $host in
@@ -4342,6 +4402,28 @@
 # check for endianness
 AC_C_BIGENDIAN
 
+# REPARSE_DATA_BUFFER is in winnt.h on mingw32 and (unusably) ddk/ntifs.h on mingw64.
+case $host in
+  *-*-mingw*)
+AC_CACHE_CHECK([if struct REPARSE_DATA_BUFFER is in winnt.h],
+[ac_cv_struct_reparse_data_buffer_in_winnt_h],
+  [AC_COMPILE_IFELSE(
+    [AC_LANG_PROGRAM(
+      [#include <windows.h>
+       #include <winnt.h>],
+      [REPARSE_DATA_BUFFER rdb],
+    )],
+    [ac_cv_struct_reparse_data_buffer_in_winnt_h=yes],
+    [ac_cv_struct_reparse_data_buffer_in_winnt_h=no]
+  )
+])
+if test "x${ac_cv_struct_reparse_data_buffer_in_winnt_h}" = xyes; then
+  AC_DEFINE([REPARSE_DATA_BUFFER_IN_WINNT], [], [REPARSE_DATA_BUFFER in winnt.h])
+  AC_SUBST(REPARSE_DATA_BUFFER_IN_WINNT)
+fi
+  ;;
+esac
+
 # ABI version string for Python extension modules.  This appears between the
 # periods in shared library file names, e.g. foo.<SOABI>.so.  It is calculated
 # from the following attributes which affect the ABI of this Python build (in
@@ -5005,7 +5087,8 @@
     # FIXME: why windows builds don't use PC/frozen_dllmain.o ?
     PYTHON_OBJS_FROZENMAIN=""
     # default sys.path calculations for windows platforms
-    MODULE_GETPATH=PC/getpathp.o
+    # MODULE_GETPATH=PC/getpathp.o
+    MODULE_GETPATH=Modules/getpath.o
     ;;
 esac
 
diff -urN a/Include/fileutils.h b/Include/fileutils.h
--- a/Include/fileutils.h	2013-12-11 01:53:43.738568400 +0000
+++ b/Include/fileutils.h	2013-12-11 01:53:48.593846100 +0000
@@ -15,7 +15,7 @@
     const wchar_t *text,
     size_t *error_pos);
 
-#if defined(HAVE_STAT) && !defined(MS_WINDOWS)
+#if defined(HAVE_STAT) && (!defined(MS_WINDOWS) || defined(__MINGW32__))
 PyAPI_FUNC(int) _Py_wstat(
     const wchar_t* path,
     struct stat *buf);
diff -urN a/Include/osdefs.h b/Include/osdefs.h
--- a/Include/osdefs.h	2013-12-11 01:53:43.750569100 +0000
+++ b/Include/osdefs.h	2013-12-11 01:53:48.595846200 +0000
@@ -10,7 +10,7 @@
 /* Mod by chrish: QNX has WATCOM, but isn't DOS */
 #if !defined(__QNX__)
 #if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__DJGPP__) || defined(PYOS_OS2)
-#if defined(PYOS_OS2) && defined(PYCC_GCC)
+#if (defined(PYOS_OS2) && defined(PYCC_GCC)) || defined(__MINGW32__)
 #define MAXPATHLEN 260
 #define SEP L'/'
 #define ALTSEP L'\\'
@@ -22,6 +22,7 @@
 #endif
 #endif
 #define DELIM L';'
+#define DELIMSTR ";"
 #endif
 #endif
 
@@ -50,6 +51,7 @@
 /* Search path entry delimiter */
 #ifndef DELIM
 #define DELIM L':'
+#define DELIMSTR ":"
 #endif
 
 #ifdef __cplusplus
diff -urN a/Lib/plat-generic/regen b/Lib/plat-generic/regen
--- a/Lib/plat-generic/regen	2013-12-11 01:53:44.137591200 +0000
+++ b/Lib/plat-generic/regen	2013-12-11 01:53:48.596846300 +0000
@@ -1,3 +1,9 @@
 #! /bin/sh
 set -v
-eval $PYTHON_FOR_BUILD ../../Tools/scripts/h2py.py -i "'(u_long)'" /usr/include/netinet/in.h
+if [ -n "$1" ]; then
+    CCINSTALL=$($1 -print-search-dirs | head -1 | cut -d' ' -f2)
+    REGENHEADER=${CCINSTALL//\\//}/include/stddef.h
+else
+    REGENHEADER=/usr/include/netinet/in.h
+fi
+eval $PYTHON_FOR_BUILD ../../Tools/scripts/h2py.py -i "'(u_long)'" $REGENHEADER
diff -urN a/Lib/sysconfig.py b/Lib/sysconfig.py
--- a/Lib/sysconfig.py	2013-12-11 01:53:44.184593900 +0000
+++ b/Lib/sysconfig.py	2013-12-11 01:54:43.417981900 +0000
@@ -350,6 +350,14 @@
         if isinstance(v, str):
             done[k] = v.strip()
 
+    # any keys that have one with the same name suffixed with _b2h
+    # need to be replaced with the value of the _b2h key.
+    # This converts from MSYS*/Cygwin paths to Windows paths.
+    for k, v in done.items():
+        if isinstance(k, str):
+            if k.endswith("_b2h"):
+                done[k[:-4]]=v
+ 
     # save the results in the global dictionary
     vars.update(done)
     return vars
diff -urN a/Makefile.pre.in b/Makefile.pre.in
--- a/Makefile.pre.in	2013-12-11 01:53:44.836631200 +0000
+++ b/Makefile.pre.in	2013-12-11 01:53:48.598846400 +0000
@@ -29,6 +29,9 @@
 VPATH=		@srcdir@
 abs_srcdir=	@abs_srcdir@
 abs_builddir=	@abs_builddir@
+VPATH_b2h=	@VPATH_b2h@
+abs_srcdir_b2h=	@abs_srcdir_b2h@
+abs_builddir_b2h=	@abs_builddir_b2h@
 
 
 CC=		@CC@
@@ -93,7 +96,8 @@
 # C flags used for building the interpreter object files
 PY_CORE_CFLAGS=	$(PY_CFLAGS) $(PY_CPPFLAGS) $(CFLAGSFORSHARED) -DPy_BUILD_CORE
 
-
+# ; on Windows otherwise :
+DELIM=		@DELIM@
 # Machine-dependent subdirectories
 MACHDEP=	@MACHDEP@
 
@@ -642,7 +646,7 @@
 		-DPREFIX='"$(prefix)"' \
 		-DEXEC_PREFIX='"$(exec_prefix)"' \
 		-DVERSION='"$(VERSION)"' \
-		-DVPATH='"$(VPATH)"' \
+		-DVPATH='"$(VPATH_b2h)"' \
 		-o $@ $(srcdir)/Modules/getpath.c
 
 # default sys.path calculations for windows platforms
@@ -962,6 +966,7 @@
 	if test -f $(LDLIBRARY); then \
 		if test -n "$(DLLLIBRARY)" ; then \
 			$(INSTALL_SHARED) $(DLLLIBRARY) $(DESTDIR)$(BINDIR); \
+			mkdir -p $(DESTDIR)$(LIBPL); $(INSTALL_SHARED) $(LDLIBRARY) $(DESTDIR)$(LIBPL); \
 		else \
 			$(INSTALL_SHARED) $(LDLIBRARY) $(DESTDIR)$(LIBDIR)/$(INSTSONAME); \
 			if test $(LDLIBRARY) != $(INSTSONAME); then \
@@ -1165,7 +1170,7 @@
 	else \
 	  PYTHON_FOR_BUILD="$(PYTHON_FOR_BUILD)"; \
 	fi; \
-	cd $(srcdir)/Lib/$(PLATDIR); $(RUNSHARED) ./regen
+	cd $(srcdir)/Lib/$(PLATDIR); $(RUNSHARED) ./regen "$(CC)"
 
 python-config: $(srcdir)/Misc/python-config.in
 	# Substitution happens here, as the completely-expanded BINDIR
diff -urN a/Modules/getpath.c b/Modules/getpath.c
--- a/Modules/getpath.c	2013-12-11 01:53:44.893634500 +0000
+++ b/Modules/getpath.c	2013-12-11 01:53:48.601846600 +0000
@@ -10,6 +10,10 @@
 #include <mach-o/dyld.h>
 #endif
 
+#ifdef MS_WINDOWS
+#include <windows.h>
+#endif
+
 /* Search in some common locations for the associated Python libraries.
  *
  * Two directories must be found, the platform independent directory
@@ -122,7 +126,7 @@
 #endif
 
 #ifndef PYTHONPATH
-#define PYTHONPATH PREFIX "/lib/python" VERSION ":" \
+#define PYTHONPATH PREFIX "/lib/python" VERSION DELIMSTR \
               EXEC_PREFIX "/lib/python" VERSION "/lib-dynload"
 #endif
 
@@ -130,9 +134,17 @@
 #define LANDMARK L"os.py"
 #endif
 
+#ifdef __MINGW32__
+#define wcstok(line, delim, pointer)  wcstok(line, delim)
+#endif
+
 static wchar_t prefix[MAXPATHLEN+1];
 static wchar_t exec_prefix[MAXPATHLEN+1];
 static wchar_t progpath[MAXPATHLEN+1];
+#ifdef MS_WINDOWS
+static wchar_t dllpath[MAXPATHLEN+1];
+extern HANDLE PyWin_DLLhModule;
+#endif
 static wchar_t *module_search_path = NULL;
 static int module_search_path_malloced = 0;
 static wchar_t *lib_python = L"lib/python" VERSION;
@@ -143,7 +155,7 @@
     size_t i = wcslen(dir);
     while (i > 0 && dir[i] != SEP)
         --i;
-    dir[i] = '\0';
+    dir[i] = 0;
 }
 
 static int
@@ -213,7 +225,11 @@
 joinpath(wchar_t *buffer, wchar_t *stuff)
 {
     size_t n, k;
+#ifdef MS_WINDOWS
+    if (stuff[0] == SEP || (stuff[0] != 0 && stuff[1] == L':'))
+#else
     if (stuff[0] == SEP)
+#endif
         n = 0;
     else {
         n = wcslen(buffer);
@@ -234,7 +250,11 @@
 static void
 copy_absolute(wchar_t *path, wchar_t *p, size_t pathlen)
 {
+#ifdef MS_WINDOWS
+    if (p[0] == SEP || (p[0] != 0 && p[1] == L':'))
+#else
     if (p[0] == SEP)
+#endif
         wcscpy(path, p);
     else {
         if (!_Py_wgetcwd(path, pathlen)) {
@@ -254,7 +274,11 @@
 {
     wchar_t buffer[MAXPATHLEN+1];
 
+#ifdef MS_WINDOWS
+    if (path[0] == SEP || (path[0] != 0 && path[1] == L':'))
+#else
     if (path[0] == SEP)
+#endif
         return;
     copy_absolute(buffer, path, MAXPATHLEN+1);
     wcscpy(path, buffer);
@@ -459,6 +483,35 @@
     return 0;
 }
 
+#ifdef MS_WINDOWS
+/* Calculates dllpath and progpath, replacing \\ with / */
+int GetWindowsModulePaths()
+{
+    int result = 0;
+    wchar_t* seps;
+    result = GetModuleFileNameW(NULL, progpath, MAXPATHLEN);
+    seps = wcschr(progpath, L'\\');
+    while(seps) {
+        *seps = L'/';
+        seps = wcschr(seps, L'\\');
+    }
+    dllpath[0] = 0;
+#ifdef Py_ENABLE_SHARED
+    if (PyWin_DLLhModule) {
+        if((GetModuleFileNameW(PyWin_DLLhModule, dllpath, MAXPATHLEN) > 0)) {
+            result = 1;
+            seps = wcschr(dllpath, L'\\');
+            while(seps) {
+                *seps = L'/';
+                seps = wcschr(seps, L'\\');
+            }
+        }
+    }
+#endif
+    return result;
+}
+#endif /* MS_WINDOWS */
+
 static void
 calculate_path(void)
 {
@@ -535,6 +588,10 @@
         }
     }
 #endif /* __APPLE__ */
+#ifdef MS_WINDOWS
+    else if(GetWindowsModulePaths()) {
+    }
+#endif /* MS_WINDOWS */
     else if (path) {
         while (1) {
             wchar_t *delim = wcschr(path, DELIM);
@@ -564,7 +621,11 @@
         progpath[0] = '\0';
     if (path_buffer != NULL)
         PyMem_Free(path_buffer);
+#ifdef MS_WINDOWS
+    if (progpath[0] != '\0' && progpath[0] != SEP && progpath[1] != L':')
+#else
     if (progpath[0] != SEP && progpath[0] != '\0')
+#endif
         absolutize(progpath);
     wcsncpy(argv0_path, progpath, MAXPATHLEN);
     argv0_path[MAXPATHLEN] = '\0';
@@ -881,7 +942,43 @@
 }
 
 
-#ifdef __cplusplus
+#ifdef MS_WINDOWS
+/* Load python3.dll before loading any extension module that might refer
+   to it. That way, we can be sure that always the python3.dll corresponding
+   to this python DLL is loaded, not a python3.dll that might be on the path
+   by chance.
+   Return whether the DLL was found.
+*/
+static int python3_checked = 0;
+static HANDLE hPython3;
+int
+_Py_CheckPython3()
+{
+    wchar_t py3path[MAXPATHLEN+1];
+    wchar_t *s;
+    if (python3_checked)
+        return hPython3 != NULL;
+    python3_checked = 1;
+
+    /* If there is a python3.dll next to the python3y.dll,
+       assume this is a build tree; use that DLL */
+    wcscpy(py3path, dllpath);
+    s = wcsrchr(py3path, L'\\');
+    if (!s)
+        s = py3path;
+    wcscpy(s, L"\\python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    if (hPython3 != NULL)
+        return 1;
+
+    /* Check sys.prefix\DLLs\python3.dll */
+    wcscpy(py3path, Py_GetPrefix());
+    wcscat(py3path, L"\\DLLs\\python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    return hPython3 != NULL;
 }
 #endif
 
+#ifdef __cplusplus
+}
+#endif
diff -urN a/Modules/posixmodule.c b/Modules/posixmodule.c
--- a/Modules/posixmodule.c	2013-12-11 01:53:44.902635000 +0000
+++ b/Modules/posixmodule.c	2013-12-11 01:53:48.607846900 +0000
@@ -932,7 +932,7 @@
 }
 
 /* A helper used by a number of POSIX-only functions */
-#ifndef MS_WINDOWS
+#if !defined(MS_WINDOWS) || defined(__MINGW32__)
 static int
 _parse_off_t(PyObject* arg, void* addr)
 {
@@ -3582,7 +3582,7 @@
             Py_END_ALLOW_THREADS
             /* FindNextFile sets error to ERROR_NO_MORE_FILES if
                it got to the end of the directory. */
-            if (!result && GetLastError() != ERROR_NO_MORE_FILES) {
+            if (!result && GetLastError() != 0 && GetLastError() != ERROR_NO_MORE_FILES) {
                 Py_DECREF(list);
                 list = win32_error_unicode("FindNextFileW", wnamebuf);
                 goto exit;
@@ -3637,7 +3637,7 @@
         Py_END_ALLOW_THREADS
         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
            it got to the end of the directory. */
-        if (!result && GetLastError() != ERROR_NO_MORE_FILES) {
+        if (!result && GetLastError() != 0 && GetLastError() != ERROR_NO_MORE_FILES) {
             Py_DECREF(list);
             list = win32_error("FindNextFile", namebuf);
             goto exit;
diff -urN a/Modules/Setup.config.in b/Modules/Setup.config.in
--- a/Modules/Setup.config.in	2013-12-11 01:53:44.907635300 +0000
+++ b/Modules/Setup.config.in	2013-12-11 01:53:48.609847000 +0000
@@ -15,6 +15,8 @@
 # On win32 host(mingw build in MSYS environment) show that site.py
 # fail to load if some modules are not build-in:
 @BUILDIN_WIN32_MODULE@winreg ../PC/winreg.c
+@BUILDIN_WIN32_MODULE@time timemodule.c
+@BUILDIN_WIN32_MODULE@msvcrt ../PC/msvcrtmodule.c
 
 
 # The rest of the modules previously listed in this file are built
diff -urN a/Modules/Setup.dist b/Modules/Setup.dist
--- a/Modules/Setup.dist	2013-12-11 01:53:44.908635300 +0000
+++ b/Modules/Setup.dist	2013-12-11 01:53:48.611847100 +0000
@@ -84,14 +84,14 @@
 # Empty since this is now just the runtime prefix.
 DESTPATH=
 
-# Site specific path components -- should begin with : if non-empty
+# Site specific path components -- should begin with $(DELIM) if non-empty
 SITEPATH=
 
 # Standard path components for test modules
 TESTPATH=
 
 # Path components for machine- or system-dependent modules and shared libraries
-MACHDEPPATH=:plat-$(MACHDEP)
+MACHDEPPATH=$(DELIM)plat-$(MACHDEP)
 EXTRAMACHDEPPATH=
 
 COREPYTHONPATH=$(DESTPATH)$(SITEPATH)$(TESTPATH)$(MACHDEPPATH)$(EXTRAMACHDEPPATH)
diff -urN a/Python/fileutils.c b/Python/fileutils.c
--- a/Python/fileutils.c	2013-12-11 01:53:45.499669100 +0000
+++ b/Python/fileutils.c	2013-12-11 01:53:48.613847200 +0000
@@ -491,7 +491,7 @@
    Not sure whether the MS_WINDOWS guards are necessary:
    perhaps for cygwin/mingw builds?
 */
-#if defined(HAVE_STAT) && !defined(MS_WINDOWS)
+#if defined(HAVE_STAT) && (!defined(MS_WINDOWS) || defined(__MINGW32__))
 
 /* Get file status. Encode the path to the locale encoding. */
 
diff -urN a/Python/pythonrun.c b/Python/pythonrun.c
--- a/Python/pythonrun.c	2013-12-11 01:53:45.516670100 +0000
+++ b/Python/pythonrun.c	2013-12-11 01:53:48.616847400 +0000
@@ -791,6 +791,13 @@
 void
 Py_SetProgramName(wchar_t *pn)
 {
+#ifdef __MINGW32__
+    wchar_t* seps = wcschr(pn, ALTSEP);
+    while(seps) {
+        *seps = SEP;
+        seps = wcschr(seps, ALTSEP);
+    }
+#endif
     if (pn && *pn)
         progname = pn;
 }
